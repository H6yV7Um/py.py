/**  
利用Buffer写的一个LRU缓存，capacity为缓存容量，为0时不限容量。
myCache = oojs.create(CacheLRU, {capacity:65535}); //构造缓存
myCache.get(key); //读取名为key的缓存值
myCache.put(key, value); //写入名为key的缓存值
myCache.remove(key); //删除名为key的缓存值
myCache.removeAll(); //清空缓存
myCache.info(); //返回myCache缓存信息
LRU原理：对所有缓存数据的key构建hash链表，当对某一数据进行get或put操作时，将其key提到链表前端（最新）。当进行put数据超出容量时，删除链表尾端（最旧）的缓存数据。
hash链表操作可直接定位key，无需历遍整个hash对象，故读写极快。缓存容量不再影响读写速度。
*/

oojs.define({
    name: 'bufferCache',
    namespace: 'rs.data',
    bufferCache: function (capacity) {
        this.capacity = capacity || Number.MAX_VALUE;
        this.data = {};
        this.hash = {};
        this.linkedList = {
            length: 0,
            head: null,
            end: null
        }
    },
    get: function (key) {
        key = '_' + key;
        var lruEntry = this.hash[key];
        if (!lruEntry) return;
        this.refresh(this.linkedList, lruEntry);
        return JSON.parse(this.data[key].toString());
    },

    put: function (key, value) {
        key = '_' + key;
        var lruEntry = this.hash[key];
        if (value === undefined) return this;
        if (!lruEntry) {
            this.hash[key] = {
                key: key
            };
            this.linkedList.length += 1;
            lruEntry = this.hash[key];
        }
        this.refresh(this.linkedList, lruEntry);
        this.data[key] = new Buffer(JSON.stringify(value));
        if (this.linkedList.length > this.capacity) this.remove(this.linkedList.end.key.slice(1));
        return this;
    },

    remove: function (key) {
        key = '_' + key;
        var lruEntry = this.hash[key];
        if (!lruEntry) return this;
        if (lruEntry === this.linkedList.head) this.linkedList.head = lruEntry.p;
        if (lruEntry === this.linkedList.end) this.linkedList.end = lruEntry.n;
        this.link(lruEntry.n, lruEntry.p);
        this.hash[key] = null;
        this.data[key] = null;
        this.linkedList.length -= 1;
        return this;
    },

    removeAll: function () {
        this.data = {};
        this.hash = {};
        this.linkedList = {
            length: 0,
            head: null,
            end: null
        }
        return this;
    },

    info: function () {
        var size = 0,
            data = this.linkedList.head;
        while (data) {
            size += this.data[data.key].length;
            data = data.p;
        }
        return {
            capacity: this.capacity,
            length: this.linkedList.length,
            size: size
        };
    },

    /**
     * 更新链表，把get或put方法操作的key提到链表head，即表示最新
     */
    refresh: function (linkedList, entry) {
        if (entry != linkedList.head) {
            if (!linkedList.end) {
                linkedList.end = entry;
            }
            else if (linkedList.end == entry) {
                linkedList.end = entry.n;
            }

            this.link(entry.n, entry.p);
            this.link(entry, linkedList.head);
            this.linkedList.head = entry;
            linkedList.head.n = null;
        }
    },

    /**
     * 对两个链表对象建立链接，形成一条链
     */
    link: function (nextEntry, prevEntry) {
        if (nextEntry != prevEntry) {
            if (nextEntry) nextEntry.p = prevEntry;
            if (prevEntry) prevEntry.n = nextEntry;
        }
    },

    /**
     * 析构函数
     */
    dispose: function () {
        this.removeAll();
    }
});